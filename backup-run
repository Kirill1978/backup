#!/usr/bin/env bash

function error() { cat <<< "$@" 1>&2; }

#$0 - полный путь к выполняемому скрипту
DIR="$( cd "$(dirname "$0")" && pwd )"

BACKUP=$DIR/backup 
LOCATIONS=$DIR/backup.locations
TARGET=/tmp/backup 
NUMBER=7
TIMESTAMP=$(date +%Y_%m_%d_%H_%M_%S)
EXIT_CODE=0

#найти строчки, к-е не начинаются с # и т.д.
#grep -v ^# $LOCATIONS | while IFS=";" read USER LOCATION T1 N1; do
#done 

while IFS=";" read USER LOCATION T1 N1; do
	#игнорировать строчки, начинающиеся с #
	[[ "$USER" =~ ^#.*$ ]] && continue
	
	#если USER или LOCATION пустой - игнорировать 
	[ -z "$USER" -o -z "$LOCATION" ] && continue 
	
	#положить в T2 TARGET, если T1 пустое
	T2=${T1:-$TARGET}/$USER
	N2=${N1:-$NUMBER}
	
	#echo $BACKUP $USER $LOCATION $T2 $N2 $TIMESTAMP  
	PATTERN=$($BACKUP $LOCATION $T2 $TIMESTAMP)
	EXIT_CODE=$?
	if [ $EXIT_CODE -ne 0 ]; then 
		error "$LOCATION -> $T2 failed!"
		continue 
	fi
	
	N3=$(( $N2+1 ))
	
	for f in $(ls -1 $PATTERN* | sort -r | tail -n +$N3); do
		rm -rf "$f"
	done 
	
done < $LOCATIONS 

